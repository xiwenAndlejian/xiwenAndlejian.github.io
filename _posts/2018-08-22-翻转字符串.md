---
layout: post
title:  '旋转字符串'
tags:
  - java
  - 算法
  - 字符串
overlay: purple
published: true

---
编程艺术：旋转字符串
链表旋转。给出一个链表和一个数k，比如，链表为1→2→3→4→5→6，k=2，则旋转后2→1→6→5→4→3，若k=3，旋转后3→2→1→6→5→4，若k=4，旋转后4→3→2→1→6→5，用程序实现。
{: .lead}
<!–-break-–>

# 旋转字符串

[编程艺术01：旋转字符串](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/01.01.md)

## 思路1：截断再拼接

假设整个链表长度为n，需要旋转k长度，原链表(S)，左链表(L)，右链表(R)
当k == 0时，旋转后的链表为n→···→5→4→3→2→1。

当k == 1时，旋转后的链表为1→n→···→5→4→3→2。

当为k(k < n) 时，旋转后的链表为k→(k-1)→···→1→n→(n-1)→···→(k+1)

我们将旋转后的链表拆成两部分，左链表为(R^T)n→(n-1)→···→(k+1)（长度n-k），右链表为(L^T)k→(k-1)→···→1（长度为k）
R^T+L^T = n→(n-1)→···→1 = S^T
因此，为了得到目标链表

1. 将原链表翻转得到S^T
2. 然后再根据k，截断S^T，获得L^T和R^T
3. 再以R^T + L^T的方式拼接，即可获得目标链表

### 解法

```java
public static ListNode rotateListNode(ListNode head, int k) {
    if (head == null) {
        return null;
    }
    // 1. 翻转链表 时间复杂度：O(n)
    head = reverseListNode(head);
    int length = 0;
    for (ListNode node = head; node != null; node = node.next) {
        length++;
    }
    // 2.获取实际需要唯一的位数 k
    k = length <= k ? k % length : k;

    ListNode left;
    ListNode right = head;
    // 3.截取获取左右链表 执行次数(n-1)/2 ~= n/2 时间复杂度：O(n)
    if (k != 0) {
        left = head;
        int n = length - k - 1;
        while (n != 0) {
            right = right.next;
            n--;
        }
    } else {
        left = null;
    }
    ListNode pre = right;
    right = right.next;
    // 断开
    pre.next = null;
    // 获取右链表的尾节点，连接左链表
    getTail(right).next = left;

    return right;
}

// 获取链表的尾节点
public static ListNode getTail(ListNode head) {
    if (head == null)
        return null;
    ListNode tail = head;
    for (ListNode node = tail.next; node != null; node = node.next) {
        tail = node;
    }
    return tail;
}
```

## 思路2：环链表

对于k=2时，原链表1→2→3→4→5→6的结果为2→1→6→5→4→3

 1. 连接链表的首尾节点，成为环形链表
 2. 断开2→3的链接，使得3成为首节点，当前链表3→4→5→6→1→2
 3. 翻转链表即得2→1→6→5→4→3

### 环链表解法

```java

public static ListNode rotateListNode(ListNode head, int k) {
        if (head == null) {
            return null;
        }
        // 获取链表长度&尾节点 时间复杂度O(n)
        ListNode tail   = null;
        int      length = 0;
        for (ListNode node = head; node != null; node = node.next) {
            tail = node;
            length++;
        }
        // 计算实际需要移动的节点
        k = k % length;
        // 更改头结点(可能) 时间复杂度O(n/2)，翻转链表 O(n)
        if (k != 0) {
            // 单链表变环表
            tail.next = head;
            ListNode pre = head;
            for (; k - 1 > 0; k--, pre = pre.next) { }
            // 记录新的结点
            ListNode newHead = pre.next;
            //断开环表变单链表
            pre.next = null;
            return reverseListNode(newHead);
        } else {
            return reverseListNode(head);
        }
    }
    ...
    此处省略 reverseListNode 代码
```
