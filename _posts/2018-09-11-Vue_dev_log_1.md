---
layout: post
title:  'Vue后台页面开发日记（一）'
tags:
  - Vue
  - 踩坑
overlay: gray
hero: /assets/img/hintersee-3601004_1920.jpg
published: true
---
记录0基础使用Vue开发后台页面的过程，包含各种踩坑
本篇主要内容：记录初次上手Vue的经历，以及关于用户登录&权限校验的修改
{: .lead}
<!–-break-–>

# Vue后台页面开发日记（一）

> 问：为什么选择使用`Vue.js`？
>
> 答：主要是想自己也能制作前端页面，并且从三大框架（`React`、`Vue`、`Angular`）来说，`Vue`相对会上手简单。

_主要内容：_

- 后台模板选择
- 初步使用工程
- 了解工程结构
- 简单的登陆相关操作修改（页面入口）

建议上手模板前先学习一下`Vue.js`的基础使用，跟着官网教程敲一下例子。

然后需要了解一下`ES6`的语法

## 后台模板选择

`Vue.js`相关的后台模板目前已经有挺多了，下面是一些我了解过的`Vue`的后台模板

- [vue-admin-template](https://github.com/xiwenAndlejian/vue-admin-template)：有配套的[博客](https://juejin.im/post/59097cd7a22b9d0065fb61d2)教你如何使用，注：vue-admin-template是简化的后台模板
- [iview-admin](https://github.com/iview/iview-admin)：中文文档，也有[教学视频](https://segmentfault.com/ls/1650000016221751?utm_source=banner)~~非免费~~

最后选择了`vue-admin-template`，原因是不错的入门博客以及更好看的样式~~个人主观意见~~。

## 初步使用工程

 **学习前我们需要先把代码`fork`到我们自己的仓库，再`clone`到本地**

`clone`到本地后，我们跟着教程执行以下命令

```shell
# 安装依赖
npm install

# 运行 dev 中配置的服务，监听9528端口
npm run dev

# 打包项目(可不执行)
npm run build
```

执行`npm run dev`后，我们的整个服务就在本地启动了，浏览器中输入`localhost:9528`就可以访问到

## 了解工程结构

### 文件夹结构

```verilog
.
├── build
├── config # 各个环境配置文件
├── src
│   ├── api # 后台接口
│   ├── assets # 静态文件路径
│   │   └── 404_images
│   ├── components # 组件
│   │   ├── Breadcrumb
│   │   ├── Hamburger
│   │   └── SvgIcon
│   ├── icons # 图标
│   │   └── svg
│   ├── router # 路由管理
│   ├── store # store配置
│   │   └── modules
│   ├── styles # 样式
│   ├── utils # 公用方法
│   └── views # 视图
│       ├── dashboard
│       ├── form
│       ├── layout
│       │   ├── components
│       │   │   └── Sidebar
│       │   └── mixin
│       ├── login
│       ├── nested
│       │   ├── menu1
│       │   │   ├── menu1-1
│       │   │   ├── menu1-2
│       │   │   │   ├── menu1-2-1
│       │   │   │   └── menu1-2-2
│       │   │   └── menu1-3
│       │   └── menu2
│       ├── table
│       └── tree
└── static
```

## 简单的登陆相关操作修改（页面入口）

### 发送请求

首先我们需要修改一下配置文件中结构的基础路径地址

```js
// dev.env.js
module.exports = merge(prodEnv, {
  NODE_ENV: '"development"',
  BASE_API: '"https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin"', //需要将这里的mock接口替换为我们自己的后台接口的基础路径
})

// 如果你的登陆接口不是/user/login（POST），那么你还需要修改api/login.js的接口设置
// api/login.js
export function login(username, password) {
  return request({
    url: '/user/login',
    method: 'post',
    data: {
      username,
      password
    }
  })
}
```

注意：这里的`request`其实用到了[axios](https://github.com/axios/axios)，主要是提供了更加方便的处理`HTTP`请求以及相应数据的方法

[request官方使用说明](https://github.com/axios/axios#request-config)

### 拦截器配置

> 发送&接受请求的公共处理流程

还需要修改服务拦截器的配置，需要根据自身服务修改这里的配置

- 请求发送的`token`头，以及`token`信息的组装（这里是加入了一个公共的token头）
- 以及修改对响应信息中的code的处理，原项目中默认成功代码为`20000`需要自行修改
- `token`过期的设置，目前暂不处理

```js
// utils/request.js
const tokenHead = 'Bearer '

// request拦截器
service.interceptors.request.use(
  config => {
    if (store.getters.token) {
      config.headers['Authorization'] = tokenHead + getToken() // 让每个请求携带自定义token 请根据实际情况自行修改
    }
    return config
  },
  error => {
    // Do something with request error
    console.log(error) // for debug
    Promise.reject(error)
  }
)

// response 拦截器
service.interceptors.response.use(
  response => {
    // code为非20000是抛错 可结合自己业务进行修改
    const res = response.data
    if (res.code !== 2000) {
      Message({
        message: res.msg,
        type: 'error',
        duration: 5 * 1000
      })

      // 50008:非法的token; 50012:其他客户端登录了;  50014:Token 过期了;
      if (res.code === 50008 || res.code === 50012 || res.code === 50014) {
        MessageBox.confirm(
          '你已被登出，可以取消继续留在该页面，或者重新登录',
          '确定登出',
          {
            confirmButtonText: '重新登录',
            cancelButtonText: '取消',
            type: 'warning'
          }
        ).then(() => {
          store.dispatch('FedLogOut').then(() => {
            location.reload() // 为了重新实例化vue-router对象 避免bug
          })
        })
      }
      return Promise.reject('error')
    } else {
        // 注意，这里返回的是response.data，因此前台接口获取数据时只会有响应的数据，而不会有响应头等信息
      return response.data
    }
  },
  error => {
    console.log('err' + error) // for debug
    Message({
      message: error.message,
      type: 'error',
      duration: 5 * 1000
    })
    return Promise.reject(error)
  }
)
```

至此，一个登录请求是可以被我们正确的发送&接受了

下一步，我们需要对接受到的用户登录信息进行处理

### 处理权限信息

从登陆组件`login/index.vue`中我们可以看到以下代码

```js
handleLogin() {
    this.$refs.loginForm.validate(valid => {
        if (valid) {
            this.loading = true
            // 此处使用了Vuex的dispatch，将表单的数据通过之前定义好的action来处理
            this.$store.dispatch('Login', this.loginForm).then(() => {
                this.loading = false
                this.$router.push({ path: '/' })
            }).catch(() => {
                this.loading = false
            })
        } else {
            console.log('error submit!!')
            return false
        }
    })
}
```

事实上是调用了`store/modules/user.js`预先设定好的`action`：

```js
// store/modules/user.js
Login({ commit }, userInfo) {
    const username = userInfo.username.trim()
    return new Promise((resolve, reject) => {
        login(username, userInfo.password).then(response => {
            console.log(response)
            const data = response.payload
            setToken(data.token)
            commit('SET_TOKEN', data.token) //把token放入全局属性中
            resolve()
        }).catch(error => {
            reject(error)
        })
    })
},
```

如果返回的数据格式与模板的不相同，则可能还需要修改`permission.js`&`user.js`中的设置

```js
// permission.js
router.beforeEach((to, from, next) => {
  NProgress.start() // start progress bar
  if (getToken()) { // determine if there has token
    /* has token*/
    if (to.path === '/login') {
      next({ path: '/' })
      // if current page is dashboard will not trigger afterEach hook, so manually handle it
      NProgress.done()
    } else {
      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息
        store.dispatch('GetInfo').then(res => { // 拉取user_info
          // 需要根据接口返回的数据结构修改
          const roles = res.payload.roles // note: roles must be a array! such as: ['editor','develop']
          store.dispatch('GenerateRoutes', { roles }).then(() => { // 根据roles权限生成可访问的路由表
            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表
            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record
          })
        }).catch((err) => {
          store.dispatch('FedLogOut').then(() => {
            Message.error(err || 'Verification failed, please login again')
            next({ path: '/' })
          })
        })
      } else {
        next()
      }
    }
  } else {
    /* has no token*/
    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
      next()
    } else {
      next('/login') // 否则全部重定向到登录页
      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it
    }
  }
})


// store/modules/user.js
GetInfo({ commit, state }) {
    return new Promise((resolve, reject) => {
        getInfo(state.token).then(response => {
            // 需要根据接口返回的数据结构修改
            const data = response.payload
            if (data.roles && data.roles.length > 0) { // 验证返回的roles是否是一个非空数组
                commit('SET_ROLES', data.roles)
            } else {
                reject('getInfo: roles must be a non-null array !')
            }
            // 获取用户信息放入全局属性中
            commit('SET_NAME', data.name)
            commit('SET_ID', data.id)
            commit('SET_AVATAR', data.avatar)
            resolve(response)
        }).catch(error => {
            reject(error)
        })
    })
},
```
